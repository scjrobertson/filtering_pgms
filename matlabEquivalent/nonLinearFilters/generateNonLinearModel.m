function model = generateNonLinearModel(clutterRate, detectionProbability)
% GENERATENONLINEARMODEL -- Generates a structure containing all simulation info.
%   model = generateNonLinearModel(detectionProbabilty, clutterRate);
%
%   Declares all simulation information, except the ground truth.
%
%   See also generateGroundTruth.
%
%   Inputs
%       clutterRate - integer. The number of expected clutter per
%           time-step. Clutter is assumed to generated by a Poisson point
%           process.
%       detectionProbability - double. The probability of the sensor
%           detecting a target-generated measurement.
%
%   Output
%       model - struct. A struct with the field declared in this function.
%% State and measurement space dimensions
model.xDimension = 4;
model.zDimension = 2;
%% Sampling period
model.T = 1;
%% Linear motion model
% State transition matrix
model.survivalProbability = 0.9; % Existing target survival probability - could be state dependent.
model.existenceThreshold = 1e-3;
model.A = [ eye(model.xDimension/2) model.T*eye(model.xDimension/2); ...
    zeros(model.xDimension/2) eye(model.xDimension/2)];
model.Atranspose = model.A'; %Precompute
model.u = zeros(model.xDimension, 1);
% Process noise
r0 = 0.3;
model.R = r0*[ (1/3)*(model.T^3)*eye(model.xDimension/2) 0.5*(model.T^2)*eye(model.xDimension/2);
    0.5*(model.T^2)*eye(model.xDimension/2) model.T*eye(model.xDimension/2)];
%% Non-linear observation model - Tranforms are performed in the code itself
% Sensor positions
model.numberOfSensors = 3;
model.sensorPosition = [500 0 -400; 0 500 -300];
model.maximumSensorRange = 250; % Thumb suck value
model.maximumDopplerVelocity = 40; % Thumb suck value
%Measurement noise
q0 = 0.3;
model.Q = q0*eye(model.zDimension);
%% Unscented transofrm parameters
model.utAlpha = 1;
model.utBeta = 1;
model.utKappa = -3;
model.utLambda = (model.utAlpha^2)*(model.xDimension + model.utKappa) - model.xDimension;
model.utGamma = model.xDimension + model.utLambda;

model.meanWeight = (1.0*model.utLambda)/(model.utGamma); 
model.covarianceWeight = model.meanWeight + (1 - model.utAlpha^2 + model.utBeta);
model.dimensionWeights = ones([1 2*model.xDimension])/(2.0*model.utGamma);
%% Detection probability
model.detectionProbability = detectionProbability; % Could be state dependent.
%% Observation space
model.observationSpaceLimits = 500*[-1 1; -1 1];
model.observationSpaceVolume = prod(model.observationSpaceLimits(:, 2) - model.observationSpaceLimits(:, 1));
model.clutterRate = clutterRate;
model.clutterPerUnitVolume = clutterRate/model.observationSpaceVolume;
%% Spawning parameters
model.numberOfSpawningLocations = 60;
model.spawnMeans(1, 1:model.numberOfSpawningLocations) = -400*ones(1, model.numberOfSpawningLocations);
model.spawnMeans(2, :) = linspace(model.observationSpaceLimits(2, 1)+50, model.observationSpaceLimits(2, 2)-50, model.numberOfSpawningLocations);
model.spawnMeans(3:4, :) = repmat([2; 1], [1 model.numberOfSpawningLocations]);
model.spawnCovariance = diag([2 2 2 2].^2);
model.spawnCovariances = reshape(repmat(model.spawnCovariance, [1 model.numberOfSpawningLocations]), [model.xDimension model.xDimension model.numberOfSpawningLocations]);
%% Poisson Point Process parameters
model.poissonSurvivalProbability = 0.5;
model.lambdaThreshold = 1e-3;
model.expectedNumberOfNewTargets = 1; %model.numberOfSpawningLocations; % Expect one new target every time-step
model.newTargetProbability = model.expectedNumberOfNewTargets/model.numberOfSpawningLocations;
%% OSPA parameters
model.ospaP = 2;
model.eOspaC = 5; % Euclidean cut-off
model.hOspaC = 1; % Hellinger cut-off
end